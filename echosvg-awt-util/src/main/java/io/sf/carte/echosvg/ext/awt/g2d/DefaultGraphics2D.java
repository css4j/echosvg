/*

   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

 */
package io.sf.carte.echosvg.ext.awt.g2d;

import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.Image;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.awt.image.ImageObserver;
import java.awt.image.RenderedImage;
import java.awt.image.renderable.RenderableImage;
import java.text.AttributedCharacterIterator;

/**
 * This concrete implementation of <code>AbstractGraphics2D</code> is a simple
 * help to programmers to get started with their own implementation of
 * <code>Graphics2D</code>. <code>DefaultGraphics2D</code> implements all the
 * abstract methods is <code>AbstractGraphics2D</code> and makes it easy to
 * start implementing a <code>Graphic2D</code> piece-meal.
 *
 * @author <a href="mailto:vincent.hardy@eng.sun.com">Vincent Hardy</a>
 * @author For later modifications, see Git history.
 * @version $Id$
 * @see io.sf.carte.echosvg.ext.awt.g2d.AbstractGraphics2D
 */
public class DefaultGraphics2D extends AbstractGraphics2D {
	/**
	 * Default constructor
	 */
	public DefaultGraphics2D(boolean textAsShapes) {
		super(textAsShapes);
	}

	/**
	 * This constructor supports the create method
	 */
	public DefaultGraphics2D(DefaultGraphics2D g) {
		super(g);
	}

	/**
	 * Creates a new <code>Graphics</code> object that is a copy of this
	 * <code>Graphics</code> object.
	 * 
	 * @return a new graphics context that is a copy of this graphics context.
	 */
	@Override
	public Graphics create() {
		return new DefaultGraphics2D(this);
	}

	/**
	 * Draws as much of the specified image as is currently available. The image is
	 * drawn with its top-left corner at (<i>x</i>,&nbsp;<i>y</i>) in this graphics
	 * context's coordinate space. Transparent pixels in the image do not affect
	 * whatever pixels are already there.
	 * <p>
	 * This method returns immediately in all cases, even if the complete image has
	 * not yet been loaded, and it has not been dithered and converted for the
	 * current output device.
	 * <p>
	 * If the image has not yet been completely loaded, then <code>drawImage</code>
	 * returns <code>false</code>. As more of the image becomes available, the
	 * process that draws the image notifies the specified image observer.
	 * 
	 * @param img      the specified image to be drawn.
	 * @param x        the <i>x</i> coordinate.
	 * @param y        the <i>y</i> coordinate.
	 * @param observer object to be notified as more of the image is converted.
	 * @see java.awt.Image
	 * @see java.awt.image.ImageObserver
	 * @see java.awt.image.ImageObserver#imageUpdate(java.awt.Image, int, int, int,
	 *      int, int)
	 */
	@Override
	public boolean drawImage(Image img, int x, int y, ImageObserver observer) {
		System.err.println("drawImage");
		return true;
	}

	/**
	 * Draws as much of the specified image as has already been scaled to fit inside
	 * the specified rectangle.
	 * <p>
	 * The image is drawn inside the specified rectangle of this graphics context's
	 * coordinate space, and is scaled if necessary. Transparent pixels do not
	 * affect whatever pixels are already there.
	 * <p>
	 * This method returns immediately in all cases, even if the entire image has
	 * not yet been scaled, dithered, and converted for the current output device.
	 * If the current output representation is not yet complete, then
	 * <code>drawImage</code> returns <code>false</code>. As more of the image
	 * becomes available, the process that draws the image notifies the image
	 * observer by calling its <code>imageUpdate</code> method.
	 * <p>
	 * A scaled version of an image will not necessarily be available immediately
	 * just because an unscaled version of the image has been constructed for this
	 * output device. Each size of the image may be cached separately and generated
	 * from the original data in a separate image production sequence.
	 * 
	 * @param img      the specified image to be drawn.
	 * @param x        the <i>x</i> coordinate.
	 * @param y        the <i>y</i> coordinate.
	 * @param width    the width of the rectangle.
	 * @param height   the height of the rectangle.
	 * @param observer object to be notified as more of the image is converted.
	 * @see java.awt.Image
	 * @see java.awt.image.ImageObserver
	 * @see java.awt.image.ImageObserver#imageUpdate(java.awt.Image, int, int, int,
	 *      int, int)
	 */
	@Override
	public boolean drawImage(Image img, int x, int y, int width, int height, ImageObserver observer) {
		System.out.println("drawImage");
		return true;
	}

	/**
	 * Disposes of this graphics context and releases any system resources that it
	 * is using. A <code>Graphics</code> object cannot be used after
	 * <code>dispose</code>has been called.
	 * <p>
	 * When a Java program runs, a large number of <code>Graphics</code> objects can
	 * be created within a short time frame. Although the finalization process of
	 * the garbage collector also disposes of the same system resources, it is
	 * preferable to manually free the associated resources by calling this method
	 * rather than to rely on a finalization process which may not run to completion
	 * for a long period of time.
	 * <p>
	 * Graphics objects which are provided as arguments to the <code>paint</code>
	 * and <code>update</code> methods of components are automatically released by
	 * the system when those methods return. For efficiency, programmers should call
	 * <code>dispose</code> when finished using a <code>Graphics</code> object only
	 * if it was created directly from a component or another <code>Graphics</code>
	 * object.
	 * 
	 * @see java.awt.Graphics#finalize
	 * @see java.awt.Component#paint
	 * @see java.awt.Component#update
	 * @see java.awt.Component#getGraphics
	 * @see java.awt.Graphics#create()
	 */
	@Override
	public void dispose() {
		System.out.println("dispose");
	}

	/**
	 * Strokes the outline of a <code>Shape</code> using the settings of the current
	 * <code>Graphics2D</code> context. The rendering attributes applied include the
	 * <code>Clip</code>, <code>Transform</code>, <code>Paint</code>,
	 * <code>Composite</code> and <code>Stroke</code> attributes.
	 * 
	 * @param s the <code>Shape</code> to be rendered
	 * @see #setStroke(java.awt.Stroke)
	 * @see #setPaint(java.awt.Paint)
	 * @see java.awt.Graphics#setColor
	 * @see #setTransform(AffineTransform)
	 * @see #setClip(Shape)
	 * @see #setComposite(java.awt.Composite)
	 */
	@Override
	public void draw(Shape s) {
		System.out.println("draw(Shape)");
	}

	/**
	 * Renders a {@link RenderedImage}, applying a transform from image space into
	 * user space before drawing. The transformation from user space into device
	 * space is done with the current <code>Transform</code> in the
	 * <code>Graphics2D</code>. The specified transformation is applied to the image
	 * before the transform attribute in the <code>Graphics2D</code> context is
	 * applied. The rendering attributes applied include the <code>Clip</code>,
	 * <code>Transform</code>, and <code>Composite</code> attributes. Note that no
	 * rendering is done if the specified transform is noninvertible.
	 * 
	 * @param img   the image to be rendered
	 * @param xform the transformation from image space into user space
	 * @see #setTransform(AffineTransform)
	 * @see #setComposite(java.awt.Composite)
	 * @see #setClip(Shape)
	 */
	@Override
	public void drawRenderedImage(RenderedImage img, AffineTransform xform) {
		System.out.println("drawRenderedImage");
	}

	/**
	 * Renders a {@link RenderableImage}, applying a transform from image space into
	 * user space before drawing. The transformation from user space into device
	 * space is done with the current <code>Transform</code> in the
	 * <code>Graphics2D</code>. The specified transformation is applied to the image
	 * before the transform attribute in the <code>Graphics2D</code> context is
	 * applied. The rendering attributes applied include the <code>Clip</code>,
	 * <code>Transform</code>, and <code>Composite</code> attributes. Note that no
	 * rendering is done if the specified transform is noninvertible.
	 * <p>
	 * Rendering hints set on the <code>Graphics2D</code> object might be used in
	 * rendering the <code>RenderableImage</code>. If explicit control is required
	 * over specific hints recognized by a specific <code>RenderableImage</code>, or
	 * if knowledge of which hints are used is required, then a
	 * <code>RenderedImage</code> should be obtained directly from the
	 * <code>RenderableImage</code> and rendered using
	 * {@link #drawRenderedImage(RenderedImage, AffineTransform) drawRenderedImage}.
	 * 
	 * @param img   the image to be rendered
	 * @param xform the transformation from image space into user space
	 * @see #setTransform(AffineTransform)
	 * @see #setComposite(java.awt.Composite)
	 * @see #setClip(Shape)
	 * @see #drawRenderedImage
	 */
	@Override
	public void drawRenderableImage(RenderableImage img, AffineTransform xform) {
		System.out.println("drawRenderableImage");
	}

	/**
	 * Renders the text specified by the specified <code>String</code>, using the
	 * current <code>Font</code> and <code>Paint</code> attributes in the
	 * <code>Graphics2D</code> context. The baseline of the first character is at
	 * position (<i>x</i>,&nbsp;<i>y</i>) in the User Space. The rendering
	 * attributes applied include the <code>Clip</code>, <code>Transform</code>,
	 * <code>Paint</code>, <code>Font</code> and <code>Composite</code> attributes.
	 * For characters in script systems such as Hebrew and Arabic, the glyphs can be
	 * rendered from right to left, in which case the coordinate supplied is the
	 * location of the leftmost character on the baseline.
	 * 
	 * @param s the <code>String</code> to be rendered
	 * @param x the x coordinate where the <code>String</code> should be rendered
	 * @param y the y coordinate where the <code>String</code> should be rendered
	 * @see #setPaint(java.awt.Paint)
	 * @see java.awt.Graphics#setColor
	 * @see java.awt.Graphics#setFont
	 * @see #setTransform(AffineTransform)
	 * @see #setComposite(java.awt.Composite)
	 * @see #setClip(Shape)
	 */
	@Override
	public void drawString(String s, float x, float y) {
		System.out.println("drawString(String)");
	}

	/**
	 * Renders the text of the specified iterator, using the <code>Graphics2D</code>
	 * context's current <code>Paint</code>. The iterator must specify a font for
	 * each character. The baseline of the first character is at position
	 * (<i>x</i>,&nbsp;<i>y</i>) in the User Space. The rendering attributes applied
	 * include the <code>Clip</code>, <code>Transform</code>, <code>Paint</code>,
	 * and <code>Composite</code> attributes. For characters in script systems such
	 * as Hebrew and Arabic, the glyphs can be rendered from right to left, in which
	 * case the coordinate supplied is the location of the leftmost character on the
	 * baseline.
	 * 
	 * @param iterator the iterator whose text is to be rendered
	 * @param x        the x coordinate where the iterator's text is to be rendered
	 * @param y        the y coordinate where the iterator's text is to be rendered
	 * @see #setPaint(java.awt.Paint)
	 * @see java.awt.Graphics#setColor
	 * @see #setTransform(AffineTransform)
	 * @see #setComposite(java.awt.Composite)
	 * @see #setClip(Shape)
	 */
	@Override
	public void drawString(AttributedCharacterIterator iterator, float x, float y) {
		System.err.println("drawString(AttributedCharacterIterator)");
	}

	/**
	 * Fills the interior of a <code>Shape</code> using the settings of the
	 * <code>Graphics2D</code> context. The rendering attributes applied include the
	 * <code>Clip</code>, <code>Transform</code>, <code>Paint</code>, and
	 * <code>Composite</code>.
	 * 
	 * @param s the <code>Shape</code> to be filled
	 * @see #setPaint(java.awt.Paint)
	 * @see java.awt.Graphics#setColor
	 * @see #setTransform(AffineTransform)
	 * @see #setComposite(java.awt.Composite)
	 * @see #setClip(Shape)
	 */
	@Override
	public void fill(Shape s) {
		System.err.println("fill");
	}

	/**
	 * Returns the device configuration associated with this
	 * <code>Graphics2D</code>.
	 */
	@Override
	public GraphicsConfiguration getDeviceConfiguration() {
		System.out.println("getDeviceConfiguration");
		return null;
	}

	/**
	 * Used to create proper font metrics
	 */
	private Graphics2D fmg;

	{
		BufferedImage bi = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB);

		fmg = bi.createGraphics();
	}

	/**
	 * Gets the font metrics for the specified font.
	 * 
	 * @return the font metrics for the specified font.
	 * @param f the specified font
	 * @see java.awt.Graphics#getFont
	 * @see java.awt.FontMetrics
	 * @see java.awt.Graphics#getFontMetrics()
	 */
	@Override
	public FontMetrics getFontMetrics(Font f) {
		return fmg.getFontMetrics(f);
	}

	/**
	 * Sets the paint mode of this graphics context to alternate between this
	 * graphics context's current color and the new specified color. This specifies
	 * that logical pixel operations are performed in the XOR mode, which alternates
	 * pixels between the current color and a specified XOR color.
	 * <p>
	 * When drawing operations are performed, pixels which are the current color are
	 * changed to the specified color, and vice versa.
	 * <p>
	 * Pixels that are of colors other than those two colors are changed in an
	 * unpredictable but reversible manner; if the same figure is drawn twice, then
	 * all pixels are restored to their original values.
	 * 
	 * @param c1 the XOR alternation color
	 */
	@Override
	public void setXORMode(Color c1) {
		System.out.println("setXORMode");
	}

	/**
	 * Copies an area of the component by a distance specified by <code>dx</code>
	 * and <code>dy</code>. From the point specified by <code>x</code> and
	 * <code>y</code>, this method copies downwards and to the right. To copy an
	 * area of the component to the left or upwards, specify a negative value for
	 * <code>dx</code> or <code>dy</code>. If a portion of the source rectangle lies
	 * outside the bounds of the component, or is obscured by another window or
	 * component, <code>copyArea</code> will be unable to copy the associated
	 * pixels. The area that is omitted can be refreshed by calling the component's
	 * <code>paint</code> method.
	 * 
	 * @param x      the <i>x</i> coordinate of the source rectangle.
	 * @param y      the <i>y</i> coordinate of the source rectangle.
	 * @param width  the width of the source rectangle.
	 * @param height the height of the source rectangle.
	 * @param dx     the horizontal distance to copy the pixels.
	 * @param dy     the vertical distance to copy the pixels.
	 */
	@Override
	public void copyArea(int x, int y, int width, int height, int dx, int dy) {
		System.out.println("copyArea");
	}

}
